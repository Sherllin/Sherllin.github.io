<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软考备考</title>
    <link href="/2024/10/08/post6/"/>
    <url>/2024/10/08/post6/</url>
    
    <content type="html"><![CDATA[<p>开始备考时间：10&#x2F;22</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><img src="/img/p6/055.jpg" alt="软考成绩" title="软考成绩"><br>实际复习时间小于一周<br>下面这些知识点说实话不是很关键，看了留个印象就行。<br>最最最重要的是做真题，像关键路径那种题几乎年年考，要会做题。<br>其次，像我这种基础薄弱，计组没学好的人，有不会的题，看不懂的名词是再正常不过了，一题一两分，无所谓的。<br>最后，23种设计模式其实没必要重点复习，重点记几个高频考的就行了，因为分值就几分。<br>做到会做的做对，看不懂的随便蒙，蒙对就是赚，蒙不对也ok，两个45分完全没什么问题的。</p><h2 id="第一章-计组"><a href="#第一章-计组" class="headerlink" title="第一章(计组)"></a>第一章(计组)</h2><h3 id="计算机内数据的表示"><a href="#计算机内数据的表示" class="headerlink" title="计算机内数据的表示"></a>计算机内数据的表示</h3><p><code>基本硬件</code><br>CPU（引脚），内存条，硬盘等</p><p><code>进制转换BODH</code><br>R进制转十进制用权重<br>十进制转R进制用短除法<br>二进制转十六进制时四位一组<br>十六进制转二进制一个对四个</p><p><code>真值</code></p><p><code>机器数</code><br>无符号数，有符号数（原，反，补，移）0正1负</p><p><code>机器字长</code><br>如一位符号位，七位数值位</p><p><code>原码</code><br>符号位加数值位，如[X]&#x3D;1,0010011,0有两种表示，机器字长为n+1，原码表示范围为-（2^n-1）到2^n-1</p><p><code>反码</code><br>正数反码与原码一样，负数的话将原码数值位全部取反就是反码。相同机器字长，表示的整数范围与原码一样</p><p><code>补码</code><br>正数补码和原码一样，负数的补码是反码末位加一（考虑进位），原码和补码不管谁转谁都是数值位按位取反，末位加一，0的表示唯一，机器字长为n+1，表示范围2^n到2^n-1</p><p><code>移码</code><br>补码符号位取反，表示范围与补码一致</p><p><code>定点数</code><br>小数点位置固定不变的数，分定点整数（0,0101.）和定点小数（0,.1000）</p><p><code>浮点数</code><br>小数点位置不固定<br>N&#x3D;M*R^E<br>N是浮点数，M是尾数，R是基数（进制），E是阶码<br>阶码决定数值范围，尾数决定数值精度</p><p><code>奇偶校验</code><br>在编码中加入一位校验位，是1的个数变为奇数（奇校验），只能发现错误</p><p><code>循环冗余校验</code></p><p><code>海明码</code><br>在数据位之间插入k位校验码，能检错纠错，数据位如果为n位，需要满足2^k-1&gt;&#x3D;n+k</p><h3 id="计算机系统组成"><a href="#计算机系统组成" class="headerlink" title="计算机系统组成"></a>计算机系统组成</h3><p><code>冯诺依曼计算机</code></p><ul><li>输入输出设备、控制器、存储器、运算器</li><li>指令和数据以同等地位存于存储器，按地址寻访</li><li>指令由操作码和地址码构成</li></ul><p><code>主存储器</code><br><img src="/img/p6/001.jpg" alt="主存储器" title="主存储器"></p><ul><li>MAR-address-地址寄存器</li><li>MDR-data-数据寄存器</li><li>存储元：存储二进制的电子元件，每个存储元存1bit</li><li>存储单元：由存储元构成，每个单元存储一串二进制代码</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储单元中二进制代码位数</li><li>4字节（Byte）&#x3D;32比特（bit）<blockquote><p>举例说明：MAR&#x3D;4，MDR&#x3D;16<br>则有2^4个存储单元，每个存储单元的存储字长为16位（bit）</p></blockquote></li></ul><p><code>CPU运算器</code><br><img src="/img/p6/002.jpg" alt="运算器" title="运算器"></p><ul><li>ACC累加器</li><li>MQ乘商寄存器</li><li>X通用的操作数寄存器</li><li>ALU算术逻辑单元</li><li>DR数据缓存寄存器</li><li>PSW状态条件寄存器，保存指令运行状态</li></ul><p><code>CPU控制器</code><br><img src="/img/p6/003.jpg" alt="控制器" title="控制器"></p><ul><li>CU控制单元：分析指令，给出控制信号</li><li>PC程序计数器：自动加一</li><li>IR指令寄存器</li><li>AR地址寄存器</li><li>ID指令译码器</li></ul><p><code>计算机体系结构（Flynn分类法）</code><br><img src="/img/p6/004.jpg" alt="体系结构" title="体系结构"></p><p><code>指令系统（指令）</code></p><ul><li>指令（机器指令）是计算机运行的最小功能单位</li><li>一台计算机所有的指令构成其指令系统，又称指令集</li><li>指令格式：操作码（OP）+地址码（A）</li></ul><p><code>指令的七种寻址方式</code></p><ol><li>立即寻址：地址码就是操作数</li><li>寄存器寻址：地址码是存放操作数的寄存器的地址</li><li>直接寻址：地址码是操作数的内存地址</li><li>寄存器间接寻址：地址码是寄存器的地址，寄存器里是操作数的内存地址</li><li>寄存器相对寻址</li><li>基址加变址寻址方式</li><li>相对基址加变址寻址</li></ol><p><code>复杂(Complex)指令集计算机CISC和精简(Reduced)指令集计算机RISC</code><br><img src="/img/p6/005.jpg" alt="指令集计算机" title="指令集计算机"></p><p><code>指令的流水处理和计算</code><br><img src="/img/p6/006.jpg" alt="指令控制方式" title="指令控制方式"><br><img src="/img/p6/007.jpg" alt="流水线周期和总时间计算" title="流水线周期和总时间计算"><br><img src="/img/p6/008.jpg" alt="吞吐率计算" title="吞吐率计算"><br><img src="/img/p6/009.jpg" alt="加速比计算" title="加速比计算"></p><p><code>输入输出技术（CPU与外设之间数据传送方式）</code></p><ol><li>直接程序控制方式<br>整个输入输出过程是在CPU执行程序的控制下完成，又分</li></ol><ul><li>无条件传送方式：无条件与CPU交换数据</li><li>程序查询方式：先通过CPU查询外设状态，准备好后再与CPU交换数据</li></ul><ol start="2"><li>中断方式<br>利用中断机制，使I&#x2F;O与外设交换数据时，CPU无需等待，也不用查询I&#x2F;O状态</li><li>直接存储器存取方式（DMA）<br>direct memory access<br>在内存与I&#x2F;O设备直接传送数据，不需要CPU任何干涉</li><li>输入&#x2F;输出处理机（不常考）<br>IOP是一个专用处理机，根据主机的I&#x2F;O命令，完成对外设数据的输入&#x2F;输出</li></ol><h3 id="存储系统、总线系统和磁盘阵列"><a href="#存储系统、总线系统和磁盘阵列" class="headerlink" title="存储系统、总线系统和磁盘阵列"></a>存储系统、总线系统和磁盘阵列</h3><p><code>存储系统</code><br><img src="/img/p6/010.jpg" alt="存储系统层次结构" title="存储系统层次结构"><br>主存-辅存：实现虚拟存储系统，解决主存容量不够的问题<br>cache-主存：解决主存与CPU速度不匹配的问题</p><p><code>存储系统分类</code></p><ul><li>按位置分：内存（主存）和外存（辅存）</li><li>按材料分：磁存储器、半导体存储器、光存储器</li><li>按工作方式分：读&#x2F;写存储器（RAM）和只读存储器（ROM）</li></ul><p><code>只读存储器（ROM）</code><br>ROM<br>PROM：programed<br>EPROM：erased+programmed<br>EEPROM：electronic+erased+programmed<br>闪存（Flash Memory）：类似eeprom，可用电信号擦除信息，速度远快于eprom</p><p><code>高速缓存cache</code><br>分两部分<br>存储部分：主存中部分信息的拷贝<br>控制部分：判断CPU要访问的信息是否在cache中，即是否命中</p><p><code>cache的三种地址映像</code></p><ol><li>直接映像<br>主存的块与cache的块一一对应<br>优：地址变换简单<br>劣：灵活性差</li><li>全相联映像<br>允许主存的任一块调入cache的任一块<br>优：不受限制、灵活<br>劣：变换复杂，速度较慢</li><li>组相联映像<br>前面两种方式的结合，将cache先分组再分块<br>组间采用直接映像，组内块间采用全相联映像</li></ol><p><code>cache性能分析</code><br><img src="/img/p6/011.jpg" alt="cache性能分析" title="cache性能分析"></p><p><code>主存的扩展</code><br><img src="/img/p6/012.jpg" alt="位扩展和字扩展" title="位扩展和字扩展"></p><p><code>主存的编制</code><br><img src="/img/p6/013.jpg" alt="主存编址例题" title="主存编址例题"><br>1K&#x3D;2^10<br>1M&#x3D;2^20<br>1G&#x3D;2^30</p><p><code>虚拟存储器</code><br>由主存、辅存、存储管理单元和操作系统中的存储管理软件组成<br>既有外存的容量，又有主存的访问速度</p><p><code>磁盘存储器</code><br><img src="/img/p6/014.jpg" alt="存取时间" title="存取时间"></p><p><code>总线系统</code><br><img src="/img/p6/015.jpg" alt="总线系统" title="总线系统"></p><p><code>磁盘阵列技术RAID</code><br><img src="/img/p6/016.jpg" alt="RAID等级" title="RAID等级"></p><p><code>计算机可靠性</code><br><img src="/img/p6/017.jpg" alt="可靠度计算" title="可靠度计算"><br>选B</p><h2 id="第二章（数据结构）"><a href="#第二章（数据结构）" class="headerlink" title="第二章（数据结构）"></a>第二章（数据结构）</h2><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p><code>数据结构三要素</code></p><ul><li>逻辑结构<br><img src="/img/p6/018.jpg" alt="逻辑结构" title="逻辑结构"></li><li>物理结构（存储结构）<br><img src="/img/p6/019.jpg" alt="物理结构" title="物理结构"></li><li>数据的运算</li></ul><p>算法五特性<br>有穷性&#x2F;确定性&#x2F;可行性&#x2F;输入&#x2F;输出</p><p><code>时间空间复杂度</code><br>函数递归：空间复杂度&#x3D;递归调用的深度<br><img src="/img/p6/020.jpg" alt="大小比较" title="大小比较"></p><h3 id="线性表-栈和队列-串数组矩阵广义表"><a href="#线性表-栈和队列-串数组矩阵广义表" class="headerlink" title="线性表&#x2F;栈和队列&#x2F;串数组矩阵广义表"></a>线性表&#x2F;栈和队列&#x2F;串数组矩阵广义表</h3><p><code>线性表</code><br><img src="/img/p6/021.jpg" alt="线性表" title="线性表"></p><p><code>链表</code><br>单链表和双向链表的增删存储单元<br>增加时，注意顺序</p><p><code>栈和队列</code><br>栈先进后出，可用于计算算式<br>队列先进先出，用于排队场景</p><p><code>循环队列</code><br><img src="/img/p6/022.jpg" alt="循环队列" title="循环队列"></p><p><code>串</code><br>空串&#x2F;空格串&#x2F;子串&#x2F;串相等&#x2F;串比较（ASCII）</p><p><code>数组存储地址计算</code><br><img src="/img/p6/023.jpg" alt="存储地址计算" title="存储地址计算"></p><p><code>广义表</code><br>取表尾：取除了表头的全部元素<br><img src="/img/p6/024.jpg" alt="广义表" title="广义表"></p><h3 id="树-二叉树-图"><a href="#树-二叉树-图" class="headerlink" title="树&#x2F;二叉树&#x2F;图"></a>树&#x2F;二叉树&#x2F;图</h3><p><code>树的基本概念</code><br><img src="/img/p6/025.jpg" alt="树" title="树"></p><blockquote><p>node的度：有几个子node，度就为几<br>tree的度：整个二叉树中，最大的node的度就为tree的度<br>叶子node：树的最末端，没有子node的node<br>根node<br>分支node<br>内部node：除了根node和叶子node的node<br>父&#x2F;子&#x2F;兄弟node<br>层次：树有几层</p></blockquote><blockquote><p>以上图为例<br>node（1）的度为2<br>tree的度为2<br>叶子node为node4，5，7，8<br>根node为node（1）<br>node（1）的分支节点为node2，3<br>内部node为node2，3，6<br>层次为4</p></blockquote><p><code>二叉树特性</code><br><img src="/img/p6/026.jpg" alt="（非）完全二叉树" title="（非）完全二叉树"></p><ul><li>第i层最多有2^(i-1)个node</li><li>深度为k的二叉树（k层）最多有2^k-1个node</li><li>任一二叉树，叶子节点为x，度为2的node的个数为y，则x&#x3D;y+1</li></ul><p><code>二叉树遍历</code><br><img src="/img/p6/027.jpg" alt="一棵树" title="一棵树"></p><blockquote><p>层次遍历：12345678<br>前序遍历（根左右）：12457836<br>中序遍历（左根右）：42785136<br>后序遍历（左右根）：48752631</p></blockquote><p><code>反向构造二叉树</code><br>eg：前序遍历为abhfdecg；中序遍历为hbedfagc</p><p><code>树转二叉树</code><br>先找兄弟结点，分组，每组兄弟结点的第一个结点保留，其余结点分别作其上一个结点的右节点</p><p><code>查找二叉树（二叉排序树）</code><br>左孩子小于根，右孩子大于根</p><p><code>构造霍夫曼树（最优树）</code><br><img src="/img/p6/028.jpg" alt="例题" title="例题"></p><p><code>线索二叉树</code><br>叶子结点上加两个指针，指向上一个节点和下一个节点（这里顺序按遍历三种方式也分成三种）</p><p><code>平衡二叉树</code><br>任一结点左右子树的深度差不超过1，每结点的平衡度只能为-1，0，1</p><p><code>图</code></p><ul><li>分有向图无向图</li><li>存储结构：邻接矩阵&#x2F;邻接表<br><img src="/img/p6/029.jpg" alt="邻接表" title="邻接表"></li><li>遍历：深度优先&#x2F;广度优先<br><img src="/img/p6/020.jpg" alt="图的遍历" title="图的遍历"></li></ul><p><code>图的最小生成树</code><br>普利姆算法：看点，然后把连接的点全部看成一个整体再去看<br>克鲁斯卡尔算法：看边，也就是看权值</p><h3 id="查找-排序"><a href="#查找-排序" class="headerlink" title="查找&amp;排序"></a>查找&amp;排序</h3><p><code>查找</code></p><ul><li>顺序查找</li><li>折半查找（向下查找）：比较次数最多为log2n取整+1，时间复杂度O（log2n）</li><li>分块查找：块间有序，块内无序</li><li>哈希表（散列表）：通过散列函数确定数据元素的位置，可能会冲突</li></ul><p><code>排序</code></p><ul><li>内部（内存）排序和外部（外存储器）排序</li><li>稳定排序和不稳定排序（如两个3，顺序确定则为稳定排序）</li></ul><p><code>直接插入排序</code><br>指针所指数据元素依次和前面已经排过序的元素进行比较</p><p><code>希尔排序</code><br>先设一个增量d，第i个元素和第i+d个元素比较，<br>然后缩小d，重复上述过程，直至d&#x3D;1</p><p><code>冒泡排序和快速排序</code></p><details>  <summary>代码</summary>  <pre><code class="hljs"> package com.example;public class test0 &#123;    public static void main(String[] args) &#123;        int[] a1=&#123;1,4,6,2,3,5&#125;;        int[] a2=&#123;1,4,6,2,3,5&#125;;        //冒泡排序：要经历n-1次冒泡，每次冒泡时两两比较        maoPao(a1);        System.out.println("冒泡排序：");        for(int z=0;z<a1.length;z++)&#123;            System.out.print(a1[z]+(z<a1.length ? "," : ""));        &#125;        System.out.println("\n");        //快速排序        int low=0;        int high=a2.length-1;        quickSort(a2, low, high);        System.out.println("快速排序：");        for(int z=0;z<a2.length;z++)&#123;            System.out.print(a2[z]+(z<a2.length ? "," : " "));        &#125;    &#125;    static void maoPao(int[] a)&#123;        int temp;        for(int j=0;j<a.length-1;j++)&#123;            for(int i=j;i<a.length-1;i++)&#123;                if(a[i]>a[i+1])&#123;                    temp=a[i+1];                    a[i+1]=a[i];                    a[i]=temp;                &#125;            &#125;        &#125;        <pre><code class="hljs">&#125;static int partition(int a[],int low,int high)&#123;    int pivotkey=a[low];    while(low&lt;high)&#123;        //先看右指针        while(low&lt;high&amp;&amp;a[high]&gt;pivotkey)&#123;            --high;        &#125;        a[low]=a[high];        //换完之后再看左指针        while(low&lt;high&amp;&amp;a[low]&lt;pivotkey)&#123;            ++low;        &#125;        a[high]=a[low];    &#125;    a[low]=pivotkey;    return low;    &#125;static void quickSort(int a[],int low,int high)&#123;    if(low&lt;high)&#123;        int pivotLoc=partition(a, low, high);        quickSort(a, low, pivotLoc-1);        quickSort(a, pivotLoc+1, high);    &#125;&#125;</code></pre><p>}<br>  </code></pre></p></details><br><p><code>简单选择排序</code><br>每次遍历一趟，选最小的放左边，以此类推</p><p><code>归并排序</code><br><img src="/img/p6/031.jpg" alt="归并排序" title="归并排序"></p><p><code>基数排序</code><br><img src="/img/p6/032.jpg" alt="基数排序" title="基数排序"></p><p><code>堆排序</code><br>先构造完全二叉树，编号<br>再找第一个非叶子结点：n&#x2F;2-1（向下取整）<br>然后比较交换，记得交换完要看子结点</p><p>插入一个数到已经排好序的堆：<br>插在最后，比较它的父结点们</p><p>删除：<br>将最后一个结点补在删去的结点，重新排序</p><p><code>排序的评价指标</code><br><img src="/img/p6/033.jpg" alt="评价指标" title="评价指标"></p><h2 id="第三章（算法）"><a href="#第三章（算法）" class="headerlink" title="第三章（算法）"></a>第三章（算法）</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>子问题独立<br>就是递归，空间复杂度&#x3D;递归调用的深度</p><h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><p>子问题不独立<br>通常用于求解具有某种最优性质问题<br>寻找最优子结构<br>整体最优</p><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>最优子结构<br>局部最优</p><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>深度优先搜索算法</p><h2 id="第四章（操作系统）"><a href="#第四章（操作系统）" class="headerlink" title="第四章（操作系统）"></a>第四章（操作系统）</h2><h3 id="基本概念和进程管理"><a href="#基本概念和进程管理" class="headerlink" title="基本概念和进程管理"></a>基本概念和进程管理</h3><p><code>操作系统特征</code><br>并发、共享、虚拟、异步（顺序不可知）<br>异步性是指各并发执行的进程以各自独立的，不可预知的速度向前推进</p><p><code>进程状态</code><br>创建态、就绪态、运行态、阻塞态、终止态<br>不能由阻塞态直接进运行态，一定要先经就绪态<br>也不能由就绪态直接进阻塞态</p><p><code>进程同步机制</code><br>为了解决异步问题<br>比如管道通信的读写顺序问题，我们想先写后读<br>就引入两个有先后关系的进程，让它们形成制约关系</p><p><code>进程互斥机制</code><br>像打印机、变量、内存缓冲区这样不能让多个程序一起使用的叫临界资源<br>所以需要互斥机制<br><img src="/img/p6/034.jpg" alt="互斥机制逻辑" title="互斥机制逻辑"><br>遵循以下原则：<br>空闲让进：临界区空闲就给进<br>忙则等待<br>有限等待：对请求访问的进程，保证在有限时间内进入临界区<br>让权等待：进程进入不了时，让出处理机</p><p><code>信号量机制</code><br><img src="/img/p6/035.jpg" alt="信号量" title="信号量"><br>能用信号量机制实现同步互斥机制<br>p就是锁定资源<br>v就是占用资源</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//同步<br>semaohore S<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;</span><br><br>p1()&#123;<br>    code <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    V(S)<span class="hljs-comment">;</span><br>    code <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br>p2()&#123;<br>    P(S)<span class="hljs-comment">;</span><br>    code <span class="hljs-number">3</span><span class="hljs-comment">;</span><br>&#125;<br>//这样能保证code3在code1后执行，实现同步机制<br></code></pre></td></tr></table></figure><p><code>死锁</code><br><img src="/img/p6/036.jpg" alt="必要条件" title="必要条件"></p><p>处理策略<br>预防、避免（银行家算法）、检测和解除<br><img src="/img/p6/037.jpg" alt="例题" title="例题"><br>解法：先求还需分配数，再求总资源剩余数，最后看哪个进程先满足条件，这个进程执行后会释放资源，以此类推<br>选B</p><h3 id="存储管理、文件管理、设备管理"><a href="#存储管理、文件管理、设备管理" class="headerlink" title="存储管理、文件管理、设备管理"></a>存储管理、文件管理、设备管理</h3><p>动态分区分配<br><code>首次适应法</code><br>每次都从低地址开始找，找到第一个能满足大小的空闲分区</p><p><code>最佳适应算法</code><br>尽可能留下大片空闲区，优先使用更小的空闲区</p><p><code>最差适应算法</code><br>优先使用最大的连续空闲区</p><p><code>邻近适应算法</code><br>每次都从上次查找结束的位置开始检索</p><p><code>分页存储管理</code><br><img src="/img/p6/038.jpg" alt="分页管理" title="分页管理"></p><p><code>分段存储管理</code><br><img src="/img/p6/039.jpg" alt="分段管理" title="分段管理"></p><p><code>段页存储管理</code><br><img src="/img/p6/038.jpg" alt="段页管理" title="段页管理"></p><p><code>页面置换算法</code></p><ul><li><p>最佳OPT（optimal）：淘汰的是以后永不使用或在最长时间内不再访问的页面</p></li><li><p>先进先出算法（FIFO）</p></li><li><p>最近最久未使用（LRU）</p></li></ul><p><code>文件的物理结构</code><br>文件的分配方式<br>连续分配、链接分配、索引分配</p><h2 id="第五章（计网）"><a href="#第五章（计网）" class="headerlink" title="第五章（计网）"></a>第五章（计网）</h2><p><code>分类</code><br>按分布范围：局域网、城域网、广域网、因特网<br>按拓扑范围分：总线型、星型、环型</p><p><code>七层网络体系结构</code><br>物理层：进行二进制的传输，中继器、集线器<br>数据链路层：传送以帧为单位的信息，网桥、交换机<br>网络层：分组传输和路由选择，三层交换机、路由器<br>传输层：端到端的连接，TCP、UDP<br>会话层、表示层、应用层</p><p><code>TCP协议</code><br>ARP，IP地址转物理地址<br>RARP，物理地址转IP地址<br>为应用程序提供一个可靠的，面向连接的数据传输服务<br>特点是可靠</p><p><code>UDP协议</code><br>不可靠、无连接的协议<br>特点是高速率</p><p><code>Internet域名服务</code><br>DNS域名服务，UDP端口，53<br>远程登陆服务，TCP端口，23<br>电子邮件服务，TCP，SMTP-25，POP3-110<br>www服务，TCP，80<br>文件传输服务，在客户机与服务器建立两条TCP连接，一条用于传输命令和参数21，一条用于传送文件20</p><h2 id="第六章（数据库）"><a href="#第六章（数据库）" class="headerlink" title="第六章（数据库）"></a>第六章（数据库）</h2><h3 id="基本概念和数据模型"><a href="#基本概念和数据模型" class="headerlink" title="基本概念和数据模型"></a>基本概念和数据模型</h3><p><code>三级模式两级映像</code><br>外模式（用户模式或子模式）：用户与数据库的接口，是用户用到的那部分数据</p><p>概念模式：全体数据的逻辑结构和特征的描述</p><p>内模式：数据物理结构和存储方式的描述</p><p><code>E-R模型</code><br>实体、联系、属性</p><p><code>关系模型</code><br>主码是下划线</p><p><code>模型转换</code><br>E-R转关系时，<br>一对多，将联系作为多的属性<br>多对多，将联系单拉出来形成一个关系模型</p><h3 id="关系代数、完整性约束、关系型数据库sql"><a href="#关系代数、完整性约束、关系型数据库sql" class="headerlink" title="关系代数、完整性约束、关系型数据库sql"></a>关系代数、完整性约束、关系型数据库sql</h3><p><code>关系代数</code><br>候选码、主码、外码、全码</p><p><code>完整性约束</code><br>防止对数据恶意破坏<br>实体完整性：主属性不能取空值<br>参照完整性：外码要么为空值，要么为其作主码那个关系的值<br>用户定义完整性</p><p><code>关系的三种类型</code><br>基本关系（基本表）<br>查询表<br>视图表（虚表）</p><p><code>七种基本运算</code><br>并、交、差、笛卡尔积、投影（对列操作）、选择（对行操作）、连接</p><h3 id="规范化、控制功能"><a href="#规范化、控制功能" class="headerlink" title="规范化、控制功能"></a>规范化、控制功能</h3><p><code>函数依赖</code><br>部分函数依赖<br>传递依赖</p><p><code>求候选码</code></p><ol><li>将函数依赖用有向图表示</li><li>找入度为0的属性，看是否能遍历全图</li><li>如果不行，再找点并入</li></ol><p><code>范式</code><br>1NF:每个属性不可再分<br>2NF：消除非主属性对主属性部分函数依赖<br>3NF：消除非主属性对主属性传递依赖<br>BCNF：消除主属性对码的部分和函数依赖</p><p><code>关系模式分解</code><br>无损连接，保持函数依赖</p><p><code>事务管理</code><br>原子性、一致性、隔离性、持久性</p><p><code>并发控制</code><br>用户对同一数据在同一时间操作，可能会产生脏数据<br>封锁协议：S封锁和X封锁<br>X锁：写锁，排他锁<br>S：读锁，共享锁</p><h2 id="第七章（程序设计）"><a href="#第七章（程序设计）" class="headerlink" title="第七章（程序设计）"></a>第七章（程序设计）</h2><p><code>编译与解释</code><br>编译语言，如c语言，会将源程序翻译成等价的目标程序。<br>解释语言，如python，不产生目标程序，直接执行源程序</p><p><code>编译</code><br>词法分析：从前到后，从左到右逐字符扫描，分析关键字、标识符等<br>语法分析：分析表达式、语句、程序等<br>语义分析<br>中间代码生成<br>代码优化<br>目标代码生成</p><p><code>文法</code><br>G&#x3D;（V，T，S，P）<br>V占位符<br>T终结符<br>S起始符<br>P产生式<br>0型短语文法<br>1型上下文有关法<br>2型上下文无关法<br>3型正规文法</p><p><code>有限自动机</code><br>可以用有向图或正规式表示<br>会做题就行</p><p><code>表达式</code><br>会做题就行<br>利用树的遍历求前缀、中缀、后缀表达式</p><p><code>传值与传址</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">C</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span>&#123;<br>    <span class="hljs-built_in">int</span> a=<span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">int</span> *b=&amp;a;<br><br>    func1(a,*b);<br>    print(<span class="hljs-string">&quot;a=%d,&quot;</span>,a);<br>    print(<span class="hljs-string">&quot;b=%d&quot;</span>,*b);<br>    <span class="hljs-comment">//打印出来a=10，b=20</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> *y</span>)</span>&#123;<br>    x+=<span class="hljs-number">10</span>;<br>    *y+=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第八章（软件需求）"><a href="#第八章（软件需求）" class="headerlink" title="第八章（软件需求）"></a>第八章（软件需求）</h2><h3 id="开发模型、开发方法、需求分析和系统设计"><a href="#开发模型、开发方法、需求分析和系统设计" class="headerlink" title="开发模型、开发方法、需求分析和系统设计"></a>开发模型、开发方法、需求分析和系统设计</h3><p><code>软件生存周期</code><br>可行性分析、需求分析、概要设计、详细设计、程序编码、软件测试、维护</p><p><code>能力成熟度模型CMM</code><br>初始级、可重复级、已定义级、已管理级、优化级</p><p><code>能力成熟度模型CMMI</code><br>阶段式模型：初始的、已管理的、已定义的、点亮管理的、优化的<br>连续式模型：CL0（未完成的）、CL1（已执行的）、CL2（已管理的）、CL3（已定义级的）、CL4（定量管理的）、CL5（优化的）</p><p><code>统一过程模型UP</code><br>用例和风险驱动、以架构为中心、迭代且增量<br>阶段：初始、细化、构建、移交</p><p><code>软件开发模型</code><br>瀑布模型<br>演化模型：根据基本需求快速构造原型，不断迭代<br>增量模型：增量包<br>螺旋模型：瀑布+演化+风险分析<br>V模型：瀑布的变体<br>喷泉模型：以用户需求为动力，采用对象技术（迭代、无间隙）<br>基于构建的开发模型：演化+迭代</p><p><code>软件开发方法</code></p><ul><li>结构化方法<br>结构化分析、结构化设计、结构化程序设计<br>面向数据流开发<br>分解和抽象为原则<br>指导思想：自顶向下，逐层分解</li><li>Jackson方法<br>面向数据结构的开发方法</li><li>原型化方法</li><li>面向对象开发方法<br>面向对象分析、设计、实现<br>UML</li><li>敏捷开发方法<br>极限编程XP：价值观、原则、实践、行为<br><img src="/img/p6/041.jpg" alt="XP" title="XP"></li></ul><p><code>需求分析</code></p><ul><li>分类<br>功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密要求、可靠性要求、软件成本消耗与开发进度需求、其他非功能性要求</li></ul><p><code>系统设计</code><br>模块化、高内聚、低耦合</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p><code>原则和目的</code><br>尽早测试<br>程序员避免测试自己设计的程序<br>修改后进行回归测试<br>既要选择合理数据，也要选择不合理数据</p><p><code>测试方法</code><br>静态和动态测试<br>动态测试又分黑盒测试和白盒测试<br><img src="/img/p6/042.jpg" alt="黑白盒测试" title="黑白盒测试"></p><p><code>测试阶段</code><br>单元测试（白盒）、集成测试、确认测试、系统测试</p><p><code>项目管理</code><br>Gantt图：可以反映并发，不能反映各任务间依赖关系<br>Pert图：有向图，箭头表示任务，可以表示完成该任务需要的时间、节点看成事件，每个事件有事件号和出现该事件的最早和最晚时刻，以及一个松弛时间，不能反映并行关系</p><p><code>风险管理</code><br>风险识别、预测、评估、控制</p><p><code>软件质量模型</code><br>三层次，质量特性-质量子特性-度量指标</p><p>功能性（适合性、准确性、互用性、依从性、安全性）<br>可靠性（成熟性、容错性、易恢复性）<br>易使用性（易理解、易学、易操作）<br>效率（时间、资源）<br>可维护性（稳定性、易分析、易改变、易测试）<br>可移植性（适应性、一致性、易安装、易替换）</p><p><code>软件度量法-McCabe法</code><br>复杂性度量，又称环路度量<br><img src="/img/p6/043.jpg" alt="环的计算" title="环的计算"><br>简便计算：数图中的环，然后加一</p><h2 id="第九章（软工导论-数据流图）"><a href="#第九章（软工导论-数据流图）" class="headerlink" title="第九章（软工导论-数据流图）"></a>第九章（软工导论-数据流图）</h2><p><code>数据字典</code><br><img src="/img/p6/044.jpg" alt="数据字典" title="数据字典"></p><p><code>数据流图</code><br>基本成分：数据流、加工、文件、外部实体</p><p>注意问题：</p><ul><li>适当命名</li><li>输入数据流与输出数据流不同名</li><li>允许一个加工有多条数据流流下另一个加工</li><li>允许一个加工有两个相同输出数据流流向不同加工</li><li>保持父图子图平衡</li><li>保持数据守恒</li><li>每个加工必须有输入输出数据流</li></ul><h2 id="第十章（软工导论-UML）"><a href="#第十章（软工导论-UML）" class="headerlink" title="第十章（软工导论-UML）"></a>第十章（软工导论-UML）</h2><p><code>UML关系</code><br>依赖、关联、泛化、实现</p><p><code>类图</code><br>填类名、方法名、属性名<br>填关系<br>填多重度<br><img src="/img/p6/045.jpg" alt="类图关系" title="类图关系"></p><p><code>用例图</code><br>include、extend</p><p><code>顺序图</code></p><p><code>活动图</code></p><p><code>状态图</code></p><p><code>通信图</code></p><p><code>构件图</code></p><h2 id="第十一章（23种设计模式15’）"><a href="#第十一章（23种设计模式15’）" class="headerlink" title="第十一章（23种设计模式15’）"></a>第十一章（23种设计模式15’）</h2><p><img src="/img/p6/046.jpg" alt="设计模式23" title="设计模式23"></p><h2 id="第十二章（网络安全、多媒体）"><a href="#第十二章（网络安全、多媒体）" class="headerlink" title="第十二章（网络安全、多媒体）"></a>第十二章（网络安全、多媒体）</h2><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p><code>信息安全属性</code><br>保密性、完整性、可用性、可控性、可审查性</p><p><code>网络安全威胁</code><br>物理威胁、网络攻击、身份鉴别、编程威胁、系统漏洞<br><img src="/img/p6/047.jpg" alt="网络威胁实例1" title="网络威胁实例1"><br><img src="/img/p6/048.jpg" alt="网络威胁实例2" title="网络威胁实例2"></p><p><code>网络攻击</code><br>口令入侵、放置特洛伊木马、Dos攻击、端口扫描、网络监听、欺骗攻击（Web、Ip、Arp欺骗）、电子邮件攻击</p><p><code>防火墙技术</code><br>防火墙&#x3D;过滤路由器+代理服务器</p><ul><li>包过滤型防火墙：工作在网络层</li><li>应用代理网关防火墙：给内网和外网间访问加保险</li><li>状态检测技术防火墙：结合前两者优点、在不损失安全性的基础上将代理防火墙性能提高十倍</li></ul><p><code>加密</code></p><ul><li>对称密钥密码体系<br>加密和解密密钥相同<br>DES、IDEA、TDEA、AES、RC2、RC4、RC5</li><li>非对称密钥密码体系<br>公钥、私钥<br>一把用来加密、一把用来解密<br>RSA、Elgamal、ECC</li></ul><p><code>数字签名</code><br>接受者能核实发送者<br>发送者不能抵赖签名<br>接收者不能伪造签名<br>MD5,SHA</p><h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><p><code>音频</code><br><img src="/img/p6/049.jpg" alt="音频带宽和采样频率" title="音频带宽和采样频率"></p><p><code>图像</code><br>亮度、色调、饱和度</p><p><code>多媒体种类</code><br>感觉媒体（听觉等）、表示媒体（图片文字等）、显示媒体（显示器、键盘等物理设备）、存储媒体（光盘等）、传输媒体（光纤等）</p><p><code>多媒体计算</code><br><img src="/img/p6/050.jpg" alt="多媒体计算" title="多媒体计算"><br>1B&#x3D;8b</p><h2 id="第十三章（知识产权）"><a href="#第十三章（知识产权）" class="headerlink" title="第十三章（知识产权）"></a>第十三章（知识产权）</h2><p><code>知识产权</code><br>分工业产权和著作权<br>考察角度：保护期限、知识产权人确定、侵权判断<br><img src="/img/p6/051.jpg" alt="保护期限" title="保护期限"><br>商标10<br>发明专利20<br>外观设计10<br><img src="/img/p6/052.jpg" alt="知识产权人确定1" title="知识产权人确定1"><br><img src="/img/p6/053.jpg" alt="知识产权人确定2" title="知识产权人确定2"></p><p><code>侵权判断</code><br>公民的作品无论是否发表，都享有著作权<br>开发软件时的思想，过程，方法不受保护</p><p>没有著作权的：</p><ul><li>法律法规等官方文件</li><li>时事新闻</li><li>历法，通用数表、表格、公式<br><img src="/img/p6/054.jpg" alt="侵权判定" title="侵权判定"></li></ul><p><code>标准</code></p><ul><li>国际标准组织<br>ISO、IEC</li><li>国家标准<br>GB中国、ANSI美国、BS英国、JIS日本</li><li>区域标准<br>PASC太平洋地区标准会议<br>CEN欧洲标准委员会<br>ASAC亚洲标准咨询委员会<br>ARSO非洲地区标准化组织</li><li>行业标准<br>GJB中国军用标准<br>MIT-S美国军用标准<br>IEEE美国电子电气工程师协会</li></ul><h2 id="第十四章（专业词汇5’）"><a href="#第十四章（专业词汇5’）" class="headerlink" title="第十四章（专业词汇5’）"></a>第十四章（专业词汇5’）</h2><p><img src="/img/p6/words/01.jpg" alt="words1" title="words1"><br><img src="/img/p6/words/02.jpg" alt="words2" title="words2"><br><img src="/img/p6/words/03.jpg" alt="words3" title="words3"><br><img src="/img/p6/words/04.jpg" alt="words4" title="words4"><br><img src="/img/p6/words/05.jpg" alt="words5" title="words5"><br><img src="/img/p6/words/06.jpg" alt="words6" title="words6"><br><img src="/img/p6/words/07.jpg" alt="words7" title="words7"><br><img src="/img/p6/words/08.jpg" alt="words8" title="words8"><br><img src="/img/p6/words/09.jpg" alt="words9" title="words9"><br><img src="/img/p6/words/10.jpg" alt="words10" title="words10"><br><img src="/img/p6/words/11.jpg" alt="words11" title="words11"><br><img src="/img/p6/words/12.jpg" alt="words12" title="words12"><br><img src="/img/p6/words/13.jpg" alt="words13" title="words13"><br><img src="/img/p6/words/14.jpg" alt="words14" title="words14"><br><img src="/img/p6/words/15.jpg" alt="words15" title="words15"></p>]]></content>
    
    
    <categories>
      
      <category>学习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中级软考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明日方舟小人素材获取教程（保姆级）</title>
    <link href="/2024/10/06/post5/"/>
    <url>/2024/10/06/post5/</url>
    
    <content type="html"><![CDATA[<h3 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0. 写在前面"></a>0. 写在前面</h3><p>本教程参考借鉴B站up主教程：<a href="https://space.bilibili.com/27521">千野</a>，<a href="https://space.bilibili.com/436869932">什么是柚子茶</a></p><p>感谢每一位热爱舟舟的发电人！</p><h3 id="1-从prts下载资源"><a href="#1-从prts下载资源" class="headerlink" title="1. 从prts下载资源"></a>1. 从prts下载资源</h3><ul><li><p>打开prts官网，搜索想要下载的干员<br><a href="https://prts.wiki/">https://prts.wiki</a><br><img src="/img/p5/001.jpg" alt=" " title="搜索干员"></p></li><li><p>下拉到干员模型，按F12打开开发者模式，点击网络，然后点击加载模型<br><img src="/img/p5/002.jpg" alt=" " title="开发者模式"></p></li><li><p>有skel、atlas、png三个后缀文件，右键分别单击，在新标签页中打开<br><img src="/img/p5/003.jpg" alt=" " title="下载三个文件"></p></li></ul><blockquote><p>现在我们得到了三个文件，其中atlas和skel文件我们可以先不管，接下来要用更清晰的图片替换我们的png文件</p></blockquote><h3 id="2-游戏解包"><a href="#2-游戏解包" class="headerlink" title="2. 游戏解包"></a>2. 游戏解包</h3><blockquote><p>先说一下从这一步一直到第四步的目的吧！</p></blockquote><blockquote><p>按理来说，我们有上一步得到的三个文件就够了，但是那个png图像不够清晰，我们要让它变清晰，这样我们舟舟的小人进行贴图后才不会有毛边。</p></blockquote><blockquote><p>有小伙伴可能会说，直接拿png图片去放大不就好了？emmm，也行，但不够清晰。</p></blockquote><blockquote><p>prts官网下载下来的直接就是透明底的合成图，是由原图加alpha通道图（alpha图后文统称蒙版）合成而来，所以我们对舟进行解包，得到原图和蒙版然后进行放大，再合成，比我们直接放大合成图会更清晰！</p></blockquote><ul><li><p>下载模拟器，雷电模拟器或mumu模拟器（我用雷电模拟器演示），在模拟器里下明日方舟，然后启动更新完资源，退回主界面，打开文件管理器<br><img src="/img/p5/004.jpg" alt=" " title="下载更新完方舟后打开文件管理器"></p></li><li><p>找到chararts包，把它复制到你的电脑上<br>（不同模拟器路径可能不一样，建议搜索AB来查询。）<br>（不同模拟器复制文件夹到电脑方式可能不一样，请自行搜索）</p><blockquote><p>by the way同路径还有一个包叫skinpack是存放皮肤的，如果需要皮肤素材，也可一起复制到电脑</p></blockquote></li></ul><p><img src="/img/p5/005.jpg" alt=" " title="找到chararts文件夹"></p><ul><li><p>去Q群（716478433）下AssetStudio.v.0.16.8压缩包，自行解压，打开exe文件<br><img src="/img/p5/006.jpg" alt=" " title="打开exe文件"></p></li><li><p>点击File&gt;Load file,打开你刚刚复制到电脑的chararts文件夹，选择你要的ab文件（这里是干员的英文名或拼音，比如我推森蚺的ab文件命名是zumama）<br><img src="/img/p5/007.jpg" alt=" " title="导入ab文件"></p></li><li><p>加载完成后，点击Export&gt;All assets进行导出，只保留图里框起来的这两个文件夹<br><img src="/img/p5/008.jpg" alt=" " title="导出"><br><img src="/img/p5/009.jpg" alt=" " title="保留的文件夹"></p></li><li><p>Texture2D点进去，对比我们一开始下载的png图片，有两张是和我们下载的一样的<br><img src="/img/p5/010.jpg" alt=" " title="原图和蒙版"></p></li></ul><blockquote><p>至此，解包工作就结束啦！</p></blockquote><h3 id="3-图片放大"><a href="#3-图片放大" class="headerlink" title="3. 图片放大"></a>3. 图片放大</h3><ul><li><p>去Q群（716478433）下realesrgan-gui-v0.2.5.0压缩包，自行解压，打开exe文件，选择上一步得到的两张图片资源（按CTRL可多选），设置按照图中来就好<br><img src="/img/p5/011.jpg" alt=" " title="图片放大"></p></li><li><p>在原文件夹里得到两个放大后的图片（有realesrgan命名的两个文件）<br><img src="/img/p5/012.jpg" alt=" " title="放大后的图片"></p></li></ul><h3 id="4-图片合成替换"><a href="#4-图片合成替换" class="headerlink" title="4. 图片合成替换"></a>4. 图片合成替换</h3><blockquote><p>将刚刚放大的原图和蒙版合成透明底，并将合成的图片替换我们一开始下的png文件</p></blockquote><ul><li><p>去Q群（716478433）下GalPhotoAuto压缩包，自行解压，打开exe文件，先点<code>（2）添加处理图片</code>，左边拖入刚刚放大的蒙版图片（也就是黑白那张），右边拖入放大后的原图（有颜色那张），拖完图片后点<code>（2）选择合成规则</code><br><img src="/img/p5/013.jpg" alt=" " title="拖入蒙版和原图"></p></li><li><p>合成规则按图来就好，选择模式一，然后点执行<br><img src="/img/p5/014.jpg" alt=" " title="选择模式然后执行"></p></li><li><p>合成完后原来的蒙版和原图会被拖入一个自动创建的文件夹（可以删掉），然后生成一个合成的图片（由放大后的两张图合成而来）<br><img src="/img/p5/015.jpg" alt=" " title="合成完成"></p></li><li><p>将合成的图片替换原来下载的png文件（文件名要和一开始下的一样），这样，我们就收集完了我们需要的三个文件<br><img src="/img/p5/016.jpg" alt=" " title="小人素材所需文件"></p></li></ul><h3 id="5-放大atlas文件"><a href="#5-放大atlas文件" class="headerlink" title="5. 放大atlas文件"></a>5. 放大atlas文件</h3><blockquote><p>舟是用spine3.5开发的，在没升级前，我们获取舟舟小人的步骤如下：</p></blockquote><blockquote><p>首先和第一步一样，得到三个文件，我们不进行放大，直接在spine里用atlas文件将png进行碎图，然后将碎图进行放大，放大后再导入spine进行贴图</p></blockquote><blockquote><p>这样的话，png文件被放大，而atlas文件没有放大，这就导致在进行贴图的时候，atlas文件约束不了png文件，后果就是模型会看起来很脏</p></blockquote><blockquote><p>而如果将atlas文件和png放大一样的倍数（第2步到第4步我们将png文件放大了8倍），那么在贴图的时候atlas文件能约束了</p></blockquote><ul><li>去Q群（716478433）下atlas放大软件.exe，双击打开。选择atlas所在文件夹，然后放大倍数和我们第三步保持一致<br><img src="/img/p5/017.jpg" alt=" " title="放大atlas"></li></ul><h3 id="6-下载spinePro3-8破解版"><a href="#6-下载spinePro3-8破解版" class="headerlink" title="6. 下载spinePro3.8破解版"></a>6. 下载spinePro3.8破解版</h3><ul><li>去Q群（716478433）下spinePro3.8压缩包，自行解压，打开后按下图顺序依次点击安装即可<br><img src="/img/p5/018.jpg" alt=" " title="安装spinrPro3.8破解版"></li></ul><h3 id="7-spine解包、导入小人骨架、贴图"><a href="#7-spine解包、导入小人骨架、贴图" class="headerlink" title="7. spine解包、导入小人骨架、贴图"></a>7. spine解包、导入小人骨架、贴图</h3><ul><li><p>运行spine，点击左上角，然后点纹理解包器<br><img src="/img/p5/019.jpg" alt=" " title="打开纹理解包器"></p></li><li><p>选择atlas文件，输出路径也放在atlas所在文件夹<br><img src="/img/p5/020.jpg" alt=" " title="纹理解包器"></p></li><li><p>把skel文件拖入spine，放大倍数和上面保持一致<br><img src="/img/p5/021.jpg" alt=" " title="导入数据"></p></li><li><p>如果没有贴图，按下图顺序依次点击，文件夹选择atlas所在文件夹<br><img src="/img/p5/022.jpg" alt=" " title="进行贴图"><br><img src="/img/p5/023.jpg" alt=" " title="导入成功效果"></p></li></ul><blockquote><p>up主千野的经验：有时spine放大倍数比图片小一半会修复导入错误，比如图片放大8倍，那spine读取就是放大4倍</p></blockquote><blockquote><p>亲测有效，我上面spine倍数选8就出错，选4就可以</p></blockquote><h3 id="8-spine预览动画，导出"><a href="#8-spine预览动画，导出" class="headerlink" title="8. spine预览动画，导出"></a>8. spine预览动画，导出</h3><ul><li><p>按照下图来，将左上角切换为动画，然后右边窗口点击动画，点击想要预览的动画，将其前面的小圆圈点上，然后点击播放键即可预览<br><img src="/img/p5/024.jpg" alt=" " title="预览动画"></p></li><li><p>左上角点击图标，选择导出，一般按照下图设置导出即可，根据需要自行更改相关参数<br><img src="/img/p5/025.jpg" alt=" " title="导出设置"></p></li></ul><h3 id="9-用途"><a href="#9-用途" class="headerlink" title="9. 用途"></a>9. 用途</h3><ul><li><p>首先，你可以拿第八步导出的动画视频去进行二创</p></li><li><p>或者，你可以拿完成第五步后的三个文件（altas、skel、png）文件导入Live2DViewerEX（steam上去下载，30r），具体教程自行搜索，不在此赘述<br><img src="/img/p5/026.jpg" alt=" " title="桌宠效果图"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>明日方舟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wallpaper静态壁纸下载方法（原画质）</title>
    <link href="/2024/10/06/post4/"/>
    <url>/2024/10/06/post4/</url>
    
    <content type="html"><![CDATA[<h4 id="1-打开wallpaper，订阅想要的静态壁纸"><a href="#1-打开wallpaper，订阅想要的静态壁纸" class="headerlink" title="1. 打开wallpaper，订阅想要的静态壁纸"></a>1. 打开wallpaper，订阅想要的静态壁纸</h4><p><img src="/img/p4/001.jpg" alt=" " title="订阅壁纸"></p><h4 id="2-在已安装这里，右键壁纸，在资源管理器中打开"><a href="#2-在已安装这里，右键壁纸，在资源管理器中打开" class="headerlink" title="2. 在已安装这里，右键壁纸，在资源管理器中打开"></a>2. 在已安装这里，右键壁纸，在资源管理器中打开</h4><p><img src="/img/p4/002.jpg" alt=" " title="资源管理器打开壁纸"></p><h4 id="3-记住这个pkg后缀的文件，我们等会用到的就是它"><a href="#3-记住这个pkg后缀的文件，我们等会用到的就是它" class="headerlink" title="3. 记住这个pkg后缀的文件，我们等会用到的就是它"></a>3. 记住这个pkg后缀的文件，我们等会用到的就是它</h4><p><img src="/img/p4/003.jpg" alt=" " title="pkg后缀文件"></p><h4 id="4-去Q群（716478433）下载RePKG压缩包，进群密码为-世界和平"><a href="#4-去Q群（716478433）下载RePKG压缩包，进群密码为-世界和平" class="headerlink" title="4. 去Q群（716478433）下载RePKG压缩包，进群密码为 世界和平"></a>4. 去Q群（716478433）下载RePKG压缩包，进群密码为 世界和平</h4><h4 id="5-下载后自行解压缩，打开RePKG-GUI-exe"><a href="#5-下载后自行解压缩，打开RePKG-GUI-exe" class="headerlink" title="5. 下载后自行解压缩，打开RePKG-GUI.exe"></a>5. 下载后自行解压缩，打开RePKG-GUI.exe</h4><p><img src="/img/p4/004.jpg" alt=" " title="RePKG文件夹"></p><h4 id="6-将刚刚的pkg后缀文件拖进去，然后点击提取"><a href="#6-将刚刚的pkg后缀文件拖进去，然后点击提取" class="headerlink" title="6. 将刚刚的pkg后缀文件拖进去，然后点击提取"></a>6. 将刚刚的pkg后缀文件拖进去，然后点击提取</h4><p><img src="/img/p4/005.jpg" alt=" " title="提取pkg文件"></p><h4 id="7-提取完后原来的pkg后缀文件所在文件夹中会多一个scene文件夹"><a href="#7-提取完后原来的pkg后缀文件所在文件夹中会多一个scene文件夹" class="headerlink" title="7. 提取完后原来的pkg后缀文件所在文件夹中会多一个scene文件夹"></a>7. 提取完后原来的pkg后缀文件所在文件夹中会多一个scene文件夹</h4><p><img src="/img/p4/006.jpg" alt=" " title="scene文件夹"></p><h4 id="8-点进去后，再点materials文件夹，里面的图像文件就是原画质的壁纸文件了"><a href="#8-点进去后，再点materials文件夹，里面的图像文件就是原画质的壁纸文件了" class="headerlink" title="8. 点进去后，再点materials文件夹，里面的图像文件就是原画质的壁纸文件了"></a>8. 点进去后，再点materials文件夹，里面的图像文件就是原画质的壁纸文件了</h4><p><img src="/img/p4/007.jpg" alt=" " title="materials文件夹里的文件"><br><img src="/img/p4/008.jpg" alt=" " title="下载的壁纸"></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wallpaper壁纸下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明日方舟壁纸</title>
    <link href="/2024/09/29/post3/"/>
    <url>/2024/09/29/post3/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/mrfz1.jpg" alt="图1" title="图1"></p><p><img src="/img/mrfz2.jpg" alt="图2" title="图2"></p>]]></content>
    
    
    <categories>
      
      <category>明日方舟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>壁纸</tag>
      
      <tag>明日方舟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2024/09/28/post2/"/>
    <url>/2024/09/28/post2/</url>
    
    <content type="html"><![CDATA[<p>markdown简单来说就是用来写文章的一种轻量级标记语言<br>用来写博客是再好不过了，半小时即可掌握<br>让你做到「心中无尘，码字入神」的境界</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>有一级到六级六种标题<br>前面加几个标题就是几级标题</p><p>eg:<br><code>### 这是一个三级标题 </code><br>!注意! #后面跟一个空格</p><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>这个十分简单，只要打完一段话后用任意行空白行隔开即可</p><h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>在一句话后面加两个空格然后按回车键即可换行</p><p>!注意! 一般只需按回车键即可</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>在要加粗的字符串前后各加两个*号</p><p>eg：<br><code>你好**你好**你好</code></p><p>渲染效果：</p><blockquote><p>你好<strong>你好</strong>你好</p></blockquote><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>前后各加一个*号<br>但我试了不行<br>所以推荐直接用html语法中的em</p><p>eg：<br><code>你好&lt;em&gt;你好&lt;/em&gt;你好</code></p><p>渲染效果：</p><blockquote><p>你好<em>你好</em>你好</p></blockquote><h3 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h3><p>em和两个**号一起用就行</p><p>eg:<br><code>你好&lt;em&gt;**你好**&lt;/em&gt;你好</code></p><p>渲染效果：</p><blockquote><p>你好<em><strong>你好</strong></em>你好</p></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在要引用的句子或段落前加一个 &gt; 符号即可<br>可以嵌套引用<br>且引用里面可以使用一些markdown语法</p><p>eg：<br><code>&gt; 你好你好你好</code><br><code>&gt;&gt; - 你好你好</code></p><p>渲染效果：</p><blockquote><p>你好你好你好</p><blockquote><ul><li>你好你好</li></ul></blockquote></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在前面加 1. 即可</p><p>eg：<br><code>1. 第一</code><br><code>1. 第二</code><br><code>1. 第三</code></p><p>渲染效果：</p><blockquote><ol><li>第一</li><li>第二</li><li>第三</li></ol></blockquote><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>在前面加 - 即可</p><p>eg：<br><code>- 第一</code><br><code>- 第二</code><br><code>- 第三</code></p><p>渲染效果：</p><blockquote><ul><li>第一</li><li>第二</li><li>第三</li></ul></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>前后各加一个英文顿号即可</p><p>eg：<br><code>`我是代码块`</code></p><p>渲染效果：</p><blockquote><p><code>我是代码块</code></p></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>用三个破折号 - 即可<br>为了兼容性，在分割线前后加空白行</p><p>eg：<br>第一段</p><p><code>---</code></p><p>第二段</p><p>渲染效果：<br>第一段</p><hr><p>第二段</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h3 id="超链接（文字作网址）"><a href="#超链接（文字作网址）" class="headerlink" title="超链接（文字作网址）"></a>超链接（文字作网址）</h3><p>在要显示网址的字符串前后加中括号[]，在后面用小括号()，小括号里面填网址</p><p>eg：<br><code>这是[b站](https://bilibili.com)</code></p><p>渲染效果：<br>这是<a href="https://bilibili.com/">b站</a></p><p>!补充! 鼠标悬停会显示title文字，可选，放在圆括号中网址后面，用空格分隔</p><p>eg：<br><code>这是[b站](https://bilibili.com &quot;这是b站&quot;)</code></p><p>渲染效果：<br>这是<a href="https://bilibili.com/" title="这是b站">b站</a></p><h3 id="网址和email网址"><a href="#网址和email网址" class="headerlink" title="网址和email网址"></a>网址和email网址</h3><p>用尖括号&lt;&gt;包裹网址，可以将网址变成可点击的链接</p><p>eg：<br><code>&lt;https://bilibili.com&gt;</code><br><code>&lt;3182714956@qq.com&gt;</code></p><p>渲染效果：<br><a href="https://bilibili.com/">https://bilibili.com</a><br><a href="mailto:&#51;&#x31;&#56;&#x32;&#x37;&#49;&#x34;&#57;&#53;&#x36;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#51;&#x31;&#56;&#x32;&#x37;&#49;&#x34;&#57;&#53;&#x36;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a></p><p>!补充! 链接也可以用强调（粗体，斜体）</p><p>eg：<br>eg：<br><code>这是 &lt;em&gt;**[b站](https://bilibili.com &quot;这是b站&quot;)**&lt;/em&gt;</code></p><p>渲染效果：<br>这是 <em><strong><a href="https://bilibili.com/" title="这是b站">b站</a></strong></em></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>eg：<br><code>![明日方舟图1](/img/mrfz1.jpg &quot;除了老爷子全是我老婆&quot;)</code></p><p>渲染效果：<br><img src="/img/mrfz1.jpg" alt="明日方舟图1" title="除了老爷子全是我老婆"></p><p>!补充! 给图片添加链接</p><p>eg：<br><code>[![明日方舟图2](/img/mrfz2.jpg &quot;除了老爷子全是我老婆&quot;)](https://bilibili.com)</code></p><p>渲染效果：<br><a href="https://bilibili.com/"><img src="/img/mrfz2.jpg" alt="明日方舟图2" title="除了老爷子全是我老婆"></a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客搭建教程</title>
    <link href="/2024/09/28/post1/"/>
    <url>/2024/09/28/post1/</url>
    
    <content type="html"><![CDATA[<h1 id="博客搭建教程"><a href="#博客搭建教程" class="headerlink" title="博客搭建教程"></a>博客搭建教程</h1><p><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">https://blog.csdn.net/cat_bayi/article/details/128725230</a></p><h1 id="fluid主题用户手册"><a href="#fluid主题用户手册" class="headerlink" title="fluid主题用户手册"></a>fluid主题用户手册</h1><p><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客相关</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
